<!DOCTYPE HTML>
<!--
	Escape Velocity by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Leroy Lucas - Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="no-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<section id="header" class="wrapper">

					<!-- Logo -->
						<div id="logo">
							<h1><a href="#">2048</a></h1>
						</div>

					<!-- Nav -->
					<nav id="nav">
						<ul>
							<li class="current"><a href="index.html">Home</a></li>
							<li>
								<a href="NP_Resume.html">Resume</a>
							</li>
							<li>
								<a href="NP_PersonalProjects.html">Personal Projects</a>
								<ul>
									<li>
										<a href="#">Game Development</a>
										<ul>
											<li><a href="P_From1AU.html">From 1 AU</a></li>
											<li><a href="P_PkmFanGame.html">Pokemon Hyokyo</a></li>
										</ul>
									</li>
									<li>
										<a href="#">Code Development</a>
										<ul>
											<li><a href="P_2048.html">2048</a></li>
										</ul>
									</li>
									<li>
										<a href="#">Crafting Projects</a>
										<ul>
											<li><a href="P_BassGuitar.html">Bass Guitar</a></li>
											<li><a href="P_WoodenRudius.html">Wooden Rudius</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<a href="NP_Research Projects.html">Research Projects</a>
								<ul>
									<li><a href="P_Thesis.html">PhD Thesis</a></li>
									<li><a href="P_Papers.html">Papers</a></li>
								</ul>
							</li>
						</ul>
					</nav>

				</section>

			<!-- Main -->
				<div id="main" class="wrapper style2">
					<div class="title">Overview</div>
					<div class="container">
						
						<!-- Content -->
							<div id="content">
								<article class="box post">
									<a class="image featured"><img src="images/2048/2048_lg.png" alt="" /></a>
									<p>
										"2048" is a game I played on mobile in 2014. Now you can play it online too (<a href="https://jeu2048.fr/">2048</a>). 
										The aim of the game is to combine identical numbers to stack their values in a 4x4 grid: by combining two 2s, you get a 4, and so on. 
										Each time the player moves, a new number (a 2 or a 4) appears in the grid.
										The game stops when the grid is full and no movement is possible.
										Even though the game only ends when the player blocks himself, there is a symbolic winning number to reach: 2048.
										Reaching 2048 is already a feat for new players, as it requires a good strategy and sometimes a bit of luck.
									</p>
									<a class="image left"><img src="images/2048/pbest.png" alt="" /></a>
									<p>	
										My personal best, represented by the sum of all the numbers in the grid, is 5614, with a maximum tile of 4096. 
										That is a pretty respectable score in itself and a maximum tile of 4096 is something I have only achieved twice in all my playing time.
									</p>
									<p>
										The main limitation of the game is that a single mistake, a single false move, can cost you the game.
										Chance can also play a role, as it can erase a previous mistake: after each move, a new tile is marked with a 2 or a 4 and randomly positioned in the available space.
										And, obviously, the wrong tile being filled at the wrong time will spell disaster.
										However, the game and the problem we want to solve are fairly simple to model. 
										That is why, in 2020, I set myself the challenge of beating my own record using an algorithm.
										I thought that if I could get rid of my own tendency to play too fast and make mistakes as a result, I could improve.
									</p>
									<br>
									<p>
										Therefore, I tried to beat the game with an algorithm that I developed in Python for convinience. 
										It was more or less a 2-3 day project I would say.
									</p>
									<p>
										Disclamer: this is not an attempt to beat a world record, but simply my personal best.
									</p>

								</article>
							</div>

					</div>
				</div>

				<!-- The Process -->
				<div id="main" class="wrapper style3">
					<div class="title">The Process</div>
					<div class="container">
						
						<!-- Content -->
							<div id="content">
								<article class="box post">
									<header class="style1">
										<h2>Recoding the game in Python</h2>
									</header>
								<a class="image left"><img src="images/2048/gif_ex.gif" alt="" /></a>
								<p>
									The first step in the process was to recode the game in Python so that my algorithm could play it.
									It was pretty straightforward because all the rules of the game are fairly well documented and can be found online (including the probability of producing 2s or 4s).
								</p>
								<p>
									I've taken the time to create a simple interface for playing the game and displaying the results. In this version, the player enters a letter for a move: "z" = up, "d" = right, "q" = left and "s" = down.
									From there, I was able to play the game on this program, as shown in the little gif on the left. However, there was no animation and the movement of the tiles is not easy to understand if you're not the one playing.
									But for the purposes of the experiment, this will do.
								</p>
								<br>
								<br>
								<br>
								<header class="style1">
									<h2>What I tried</h2>
								</header>
								<p>
									The first thing I tried to do was implement a convolutional neural network (CNN) because I thought it was a good place to do it. 
									I have experimented with different configurations of multiple CNN layers with different loss functions. 
									The training was a bit difficult to set up, as I only played a few games to give the NN a starting point. 
									Most of these experiments failed at my level, as I was only able to reach a maximum of 1024 tiles by what I mostly felt was luck and brute force.
								</p>
								<p>
									My second experiment was to switch to enhanced machine learning. 
									However, to be honest, I could not find the right reward function to make it work in the few hours I spent on it. 
									Once again, the results were rather mediocre and the maximum number of 512 tiles was barely exceeded.
								</p>
								<p>
									That is when I realised: Why does everyone want to do neural networks and machine learning when there are some really good analytical solutions out there? 
									After all, the strategy I use when I play relies very little on improvisation and adaptation and could simply be coded.
									And here I am not trying to impress my superiors or ill-informed clients by selling a trendy feature, so let's get back to being smart.
								</p>
								<header class="style1">
									<h2>The Strategy</h2>
								</header>
								<a class="image left"><img src=images/2048/perfect.png" alt="" /></a>
								<p>
									When you play "2048", you quickly realise that it's much easier to substain a run if the maximum tile is placed in a corner.
									Then, a good strategy is to place the tiles in a snake-shaped pattern starting from this maximum tile, in descending order (see illustration on the left).
									This way, you can optimise your space and give yourself a better chance of achieving a high score.
									The aim of this stategy is to ensure that each tile is next to its two time tile. 
									This way, you can then trigger a domino effect as soon as you have all the tiles you need to increase your maximum tile.
									There are two reasons why the maximum tile should be in the corner. 
									First of all, it doesn't have a two time tile, so it only needs to be in contact with its halved tile; any additional contact with extra tiles is pointless and sub-optimal.
									Secondly, sticking it in a corner (say bottom right for example) allows you to keep it there by combining right and down movements; left and up movements should not be used (this is usually where game errors occur), except in very specific cases. 
								<br>
								<p>
									This is the strategy I used in my personal runs. 
									In general, getting your maximum tile out of the corner is pretty much game over after a certain point (a maximum tile of 1024 from my experience).
									Breaking the snake's pattern will also make the game incredibly difficult in the late game end.
								</p>
								<header class="style1">
									<h2>Implementing The Strategy</h2>
								</header>
								<p>
									There are two ways of doing this: you can either code most scenarios on a case-by-case basis, or you can find a way of making the algorithm evaluate the best movement for the situation by means of a simple movement evaluation function.
									As I'm lazy, I chose the second one, obviously. 
									I won't go into detail about the whole formula here, but I will mention what it is trying to achieve. 
									There are a number of principles that we want to implement:
								</p>
								<p>
									One of them is that we want the maximum tile to be placed in a corner.
									This rule is enforced by awarding extra bonus points if the information is true, and game-breaking penalties if it is false.
								</p>
								<p>
									Next, we would like the algorithm to stack the tiles as much as possible (i.e. save as much space as possible). 
									To do this, we simply try to optimise the average number of tiles per occupied tile (0 in a tile means it's not occupied).
								</p>
								<p>
									Next, we would like to implement a kind of snake model. 
									I started by simply asking that the second largest tile be placed next to the largest tile, with a system of bonuses and penalties depending on the situation.
									The extent to which you want the snake pattern to be true is a question of optimisation that we can improve later.
								</p>
								<p>
									Finally, if the movement loses at the end of the game, which we obviously don't want it to, then let's set the reward at an extremely negative level.
								</p>
								<p>
									And that's about it for the strategy. Pretty simple, isn't it? Each turn, this strategy evaluates the result of each of the 4 possible moves and rates them according to our rules.
									Now let's test it and see if we can optimise it a little.
								</p>
								<header class="style1">
									<h2>Preliminary Results and Optimisation</h2>
								</header>

								<div class="row aln-center">
									<div class="col-4 col-12-medium">
										<section class="highlight">
											<video width="400" height="400" controls>
												<source src="images/2048/imStrat 2048.mp4" type=video/mp4> 
											</video>
										</section>
									</div>
									<div class="col-8 col-12-medium">
										<section class="highlight">
											<p>
												This algorithm reaches 2048 in about 10% of runs, which is already very good. 
												However, that's not enough, I would like to beat my own record in a dominant way.
											</p>
											<p>
												So what can we do better? The first thing to consider is that after each move, a random 2 or 4 tile is added. 
												And as this is a random phenomenon, simulating the movement only once does not give a complete picture of the situation!
												One random generation may be acceptable, another may break the game and result in a loss. 
											</p>
											<p>
												So from now on, we're going to simulate 20 of them to be sure. Why 20? 
												Because there are 16 tiles in the game, by the middle and end of the game you'll have at least half of your tiles occupied, so 20 means it will probably generate moves enough times to have every possible situation.
												We could have been deterministic and calculated all the possible outcomes for each move, but, firstly, I am lazy, secondly, we trust the maths to do the job, and thirdly I am not trying to break a world record.
											</p>
										</section>
									</div>
								</div>
								<p>
									The aim of the game is NOT to get the highest possible maximum tile. It is to keep on playing!
									This means that a particular move may give you a high score in the short term, but may end your game soon afterwards. 
									We prefer to limit the risk of loss and keep the run going for as long as possible.
									So when we generate each move 20 times, we do not want to choose the move with the highest average score. 
									We want to go for the move that will allow us to continue playing the game.
									This can be translated into the move which the average reward is closer to the maximum reward while still having a high maximum reward. 
									In this way, we avoid moves that work perfectly in 95% of cases, but lead to a direct loss in the remaining 5%.
									This is what I reafer later on as the "keep playing" feature.
								</p>
								<p>
									Finally, we have looked at the next move, but what is stopping us from looking at the next move and so on? 
									In this way, we evaluate a movement not only in terms of its immediate reward, but also in terms of the next opportunity it offers.
									We could also anticipate bad situations that may arise over the course of several turns and be able to choose the safest route.
								</p>
								<header class="style1">
									<h2>Results</h2>
								</header>
								<div class="row aln-center">
									<div class="col-4 col-12-medium">
										<section class="highlight">
											
								<video width="400" height="400" controls>
									<source src="images/2048/Strat1_4096_6068_6.mp4" type=video/mp4> 
								</video>
										</section>
									</div>
									<div class="col-8 col-12-medium">
										<section class="highlight">
											<p>
												I have implemented all these solutions in several stages, and let's have a look at the results.
											</p>
											<p>
												For the first test, I looked each move 20 times and only anticipated one move (no "keep playing" feature): it reached 2048 in 19% of cases.
											</p>
											<p>
												For the second attempt, I looked each move 20 times and anticipated two moves (no "keep playing" feature): it reaches 2048 in 29% of cases.
											</p>
											<p>
												For the third attempt, I looked each move 20 times and anticipated 2 moves with a "keep playing" feature: it reached 2048 in 60% of cases. However, it never reached 4096.
											</p>
											<p>
												Finally, I looked at each move 4 times (to limit the calculation time, plus the end of the game seems to be the problem here and there are not many  empty tiles left), anticipated 3 moves with a "keep playing" function: it reaches 2048 in more than 95% of cases.
												He also reached 4096 in just 6 attempts with a score of 6068, beating my personal score of 454 pts (in just 6 attempts!!).
											</p>
										</section>
									</div>
								</div>
								
								<br>
								<br>

								<header class="style1">
									<h2>Conclusion</h2>
								</header>
								<a class="image left"><img src="images/2048/ex_poor_pattern.png" alt="" /></a>
								<p>
									So there you have it, I have beaten my personal best with a simple algorithm and a basic approach. 
									However, this can certainly be optimised. 
									The first thing that would make it easy to crush this algorithm would be to implement a snake pattern all the way. 
									Here you can see from the video that the algorithm actually does a pretty poor job of optimising its space. 
									However, it is amusing to note that the algorithm worked out all by itself that a decreasing value pattern was needed (i.e. each tiles needs to be next to its x2 and /2 tiles).
									This is something I have not implemented directly in the code. It could be a logical consequence of the rules I have implemented. 
									In particular, this probably stems from the "keep playing" function and to look few moves ahead to maximise the chances of getting a high reward on the long run.
								</p>
								<br>
								<p>
									Thus, I have no doubt that this high score could easily be beaten again if I spent a little more time on the project. 
									However, I started this project to prove that I could beat my own record, without trying to get the highest score ever, and I managed to do it in a short time and with a minimum of effort, so I would say it is a success.
								</p>
								<p>
									On reflection, I'm quite pleased with this project for a number of reasons. 
									First of all, it is a success. 
									Secondly, it shows that it is not necessary to use sophisticated techniques such as machine learning and CNN to solve problems. 
									Analytical or semi-analytical solutions will do for 99% of projects and will be easier to implement. 
									In the 18 hours or so that this project lasted, I may have spent 30% coding the game and the interface, 50% trying out advanced machine learning approaches and 20% pushing the project forward with basic approaches.
									And the worst thing is that this simple basic approach is much easier to improve: we can clearly identify how to improve the code simply by looking at the results and changing the reward function.
									Which brings me to my final point: this project is particularly satisfying for me because I have only scratched the surface of its potential.
									The approach that broke my personal record has so many flaws that I cannot even imagine what the best score it could achieve once optimised. 
								</p>

							</article>
							</div>

					</div>
				</div>

						<!-- Footer -->
						<section id="footer" class="wrapper">
							<div class="title">Contact</div>
							<div class="container">
								<div class="row">
									
									<div class="col-12 col-12-medium">
			
										<!-- Contact -->
											<section class="feature-list small">
												<div class="row">
													<div class="col-6 col-12-small">
														<section>
															<h3 class="icon solid fa-home">Location</h3>
															<p>
																Palaiseau, 91120<br />
																France
															</p>
														</section>
													</div>
													<div class="col-6 col-12-small">
														<section>
															<h3 class="icon solid fa-comment">Social</h3>
															<p>
																<a href="https://linkedin.com/in/lucas-leroy">LinkedIn</a><br />
															</p>
														</section>
													</div>
													<div class="col-6 col-12-small">
														<section>
															<h3 class="icon solid fa-envelope">Email</h3>
															<p>
																<a href="mailto:recipient@example.com">lucas.a.leroy@gmail.com</a>
															</p>
														</section>
													</div>
													<div class="col-6 col-12-small">
														<section>
															<h3 class="icon solid fa-phone">Phone</h3>
															<p>
																+33 6 32 47 76 26
															</p>
														</section>
													</div>
												</div>
											</section>
			
									</div>
								</div>
								<div id="copyright">
									<ul>
										<li>&copy; Untitled.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
									</ul>
								</div>
							</div>
						</section>
					</div>
			


		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>